import { readFile } from "fs/promises";
import { join } from "path";
import { XMLParser, XMLBuilder } from "fast-xml-parser";
import type { PropertyDefinition } from "./types.js";
import type { FileChange } from "./diff-engine.js";
import { exec as execCallback } from "child_process";
import { promisify } from "util";
import { resolveWidgetFiles } from "./helpers.js";

export interface PropertyChangeResult {
    success: boolean;
    changes: Omit<FileChange, "originalContent">[];
    summary: string;
    error?: string;
}

export class PropertyEngine {
    private xmlParser: XMLParser;
    private xmlBuilder: XMLBuilder;

    constructor() {
        this.xmlParser = new XMLParser({
            ignoreAttributes: false,
            parseTagValue: false,
            parseAttributeValue: false,
            trimValues: false
        });
        this.xmlBuilder = new XMLBuilder({
            ignoreAttributes: false,
            format: true,
            indentBy: "    ",
            suppressEmptyNode: true
        });
    }

    /**
     * Add a property to a widget with full integration
     */
    async addProperty(packagePath: string, property: PropertyDefinition): Promise<PropertyChangeResult> {
        const changes: Omit<FileChange, "originalContent">[] = [];

        try {
            // 1. Update widget XML manifest
            const xmlChange = await this.addPropertyToXml(packagePath, property);
            changes.push(xmlChange);

            // 2. Typings are generated by pluggable-widgets-tools. We do NOT edit typings manually here.

            // 3. Update editor configuration
            const editorChange = await this.addPropertyToEditorConfig(packagePath, property);
            if (editorChange) changes.push(editorChange);

            // 4. Update runtime component (if exists)
            const runtimeChange = await this.addPropertyToRuntime(packagePath, property);
            if (runtimeChange) changes.push(runtimeChange);

            return {
                success: true,
                changes,
                summary: `Added property '${property.key}' (${property.type}) to widget with ${changes.length} file changes. Typings will be regenerated via pluggable-widgets-tools during build.`
            };
        } catch (error) {
            return {
                success: false,
                changes: [],
                summary: `Failed to add property '${property.key}'`,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Rename a property across all files
     */
    async renameProperty(packagePath: string, oldKey: string, newKey: string): Promise<PropertyChangeResult> {
        const changes: Omit<FileChange, "originalContent">[] = [];

        try {
            // 1. Update widget XML
            const xmlChange = await this.renamePropertyInXml(packagePath, oldKey, newKey);
            changes.push(xmlChange);

            // 2. Typings are generated by pluggable-widgets-tools. We do NOT edit typings manually here.

            // 3. Update editor configuration
            const editorChange = await this.renamePropertyInEditorConfig(packagePath, oldKey, newKey);
            if (editorChange) changes.push(editorChange);

            // 4. Update runtime component
            const runtimeChange = await this.renamePropertyInRuntime(packagePath, oldKey, newKey);
            if (runtimeChange) changes.push(runtimeChange);

            return {
                success: true,
                changes,
                summary: `Renamed property '${oldKey}' to '${newKey}' across ${changes.length} files`
            };
        } catch (error) {
            return {
                success: false,
                changes: [],
                summary: `Failed to rename property '${oldKey}' to '${newKey}'`,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }

    /**
     * Add property to widget XML manifest
     */
    private async addPropertyToXml(
        packagePath: string,
        property: PropertyDefinition
    ): Promise<Omit<FileChange, "originalContent">> {
        const xmlFiles = await this.findWidgetXmlFiles(packagePath);
        const xmlPath = xmlFiles[0]; // Take the first widget XML file

        if (!xmlPath) {
            throw new Error("No widget XML file found");
        }

        const originalContent = await readFile(xmlPath, "utf-8");
        const xmlData = this.xmlParser.parse(originalContent);

        // Navigate to properties section
        if (!xmlData.widget?.properties) {
            throw new Error("Widget XML does not have properties section");
        }

        // Find appropriate property group or create one
        let targetGroup = this.findOrCreatePropertyGroup(xmlData.widget.properties, property.category || "General");

        // Create property XML object
        const propertyObj = this.createPropertyXmlObject(property);

        // Add property to the group
        if (!targetGroup.property) {
            targetGroup.property = [];
        } else if (!Array.isArray(targetGroup.property)) {
            targetGroup.property = [targetGroup.property];
        }

        targetGroup.property.push(propertyObj);

        const newContent = this.xmlBuilder.build(xmlData);

        return {
            filePath: xmlPath,
            newContent,
            operation: "update",
            description: `Add ${property.type} property '${property.key}' to widget XML`
        };
    }

    // Intentionally removed manual typings edits. Typings are generated by pluggable-widgets-tools during build.

    /**
     * Add property configuration to editor config
     */
    private async addPropertyToEditorConfig(
        packagePath: string,
        property: PropertyDefinition
    ): Promise<Omit<FileChange, "originalContent"> | null> {
        const editorConfigPath = await this.findEditorConfigFile(packagePath);

        if (!editorConfigPath) {
            return null;
        }

        try {
            const originalContent = await readFile(editorConfigPath, "utf-8");

            // Find properties function or object
            const propertiesRegex = /(function\s+properties\s*\([^)]*\)[^{]*\{|const\s+properties\s*=\s*\{)/;

            if (!propertiesRegex.test(originalContent)) {
                return null; // No properties configuration found
            }

            // Add property validation or visibility rules if needed
            let newContent = originalContent;

            // Add basic validation example for the property
            const validationComment = `    // Validation for ${property.key} property can be added here\n`;

            // Insert before the last return statement or closing brace
            const insertionPoint = originalContent.lastIndexOf("return") || originalContent.lastIndexOf("}");
            if (insertionPoint > -1) {
                newContent =
                    originalContent.slice(0, insertionPoint) +
                    validationComment +
                    originalContent.slice(insertionPoint);
            }

            return {
                filePath: editorConfigPath,
                newContent,
                operation: "update",
                description: `Add editor configuration for property '${property.key}'`
            };
        } catch (error) {
            return null;
        }
    }

    /**
     * Add property usage to runtime component
     */
    private async addPropertyToRuntime(
        packagePath: string,
        property: PropertyDefinition
    ): Promise<Omit<FileChange, "originalContent"> | null> {
        const runtimeFiles = await this.findRuntimeFiles(packagePath);
        const mainRuntime = runtimeFiles.find(f => f.endsWith(".tsx") && !f.includes("Preview"));

        if (!mainRuntime) {
            return null;
        }

        try {
            const originalContent = await readFile(mainRuntime, "utf-8");

            // Find the component function
            const componentRegex = /export\s+function\s+\w+\s*\([^)]*\)\s*\{/;
            const match = originalContent.match(componentRegex);

            if (!match) {
                return null;
            }

            // Add property destructuring
            const propsDestructuringRegex = /const\s*\{\s*([^}]+)\s*\}\s*=\s*props/;
            const propsMatch = originalContent.match(propsDestructuringRegex);

            let newContent = originalContent;

            if (propsMatch) {
                // Add to existing destructuring
                const existingProps = propsMatch[1];
                const newProps = existingProps.trim() + `, ${property.key}`;
                newContent = originalContent.replace(propsDestructuringRegex, `const { ${newProps} } = props`);
            } else {
                // Add new destructuring after the function declaration
                const insertionPoint = originalContent.indexOf("{", match.index! + match[0].length);
                if (insertionPoint > -1) {
                    const destructuring = `\n    const { ${property.key} } = props;\n`;
                    newContent =
                        originalContent.slice(0, insertionPoint + 1) +
                        destructuring +
                        originalContent.slice(insertionPoint + 1);
                }
            }

            return {
                filePath: mainRuntime,
                newContent,
                operation: "update",
                description: `Add property '${property.key}' usage to runtime component`
            };
        } catch (error) {
            return null;
        }
    }

    // Rename operations (similar structure but with find/replace logic)
    private async renamePropertyInXml(
        packagePath: string,
        oldKey: string,
        newKey: string
    ): Promise<Omit<FileChange, "originalContent">> {
        const xmlFiles = await this.findWidgetXmlFiles(packagePath);
        const xmlPath = xmlFiles[0];

        const originalContent = await readFile(xmlPath, "utf-8");
        const newContent = originalContent.replace(new RegExp(`key="${oldKey}"`, "g"), `key="${newKey}"`);

        return {
            filePath: xmlPath,
            newContent,
            operation: "update",
            description: `Rename property key from '${oldKey}' to '${newKey}' in XML`
        };
    }

    // Intentionally removed manual typings edits. Typings are generated by pluggable-widgets-tools during build.

    private async renamePropertyInEditorConfig(
        packagePath: string,
        oldKey: string,
        newKey: string
    ): Promise<Omit<FileChange, "originalContent"> | null> {
        const editorConfigPath = await this.findEditorConfigFile(packagePath);
        if (!editorConfigPath) return null;

        try {
            const originalContent = await readFile(editorConfigPath, "utf-8");
            const newContent = originalContent.replace(new RegExp(`["'\`]${oldKey}["'\`]`, "g"), `"${newKey}"`);

            return {
                filePath: editorConfigPath,
                newContent,
                operation: "update",
                description: `Rename property '${oldKey}' to '${newKey}' in editor config`
            };
        } catch {
            return null;
        }
    }

    private async renamePropertyInRuntime(
        packagePath: string,
        oldKey: string,
        newKey: string
    ): Promise<Omit<FileChange, "originalContent"> | null> {
        const runtimeFiles = await this.findRuntimeFiles(packagePath);
        const mainRuntime = runtimeFiles.find(f => f.endsWith(".tsx") && !f.includes("Preview"));

        if (!mainRuntime) return null;

        try {
            const originalContent = await readFile(mainRuntime, "utf-8");
            const newContent = originalContent.replace(new RegExp(`\\b${oldKey}\\b`, "g"), newKey);

            return {
                filePath: mainRuntime,
                newContent,
                operation: "update",
                description: `Rename property '${oldKey}' to '${newKey}' in runtime component`
            };
        } catch {
            return null;
        }
    }

    // Helper methods
    private async findWidgetXmlFiles(packagePath: string): Promise<string[]> {
        try {
            const resolved = await resolveWidgetFiles(packagePath);
            if (resolved.widgetXmlPath) return [resolved.widgetXmlPath];
        } catch {
            // ignore
        }
        return [];
    }

    private async findEditorConfigFile(packagePath: string): Promise<string | null> {
        try {
            const resolved = await resolveWidgetFiles(packagePath);
            return resolved.editorConfigPath ?? null;
        } catch {
            return null;
        }
    }

    private async findRuntimeFiles(packagePath: string): Promise<string[]> {
        const srcPath = join(packagePath, "src");
        const { readdir } = await import("fs/promises");

        try {
            const files = await readdir(srcPath);
            return files.filter(f => f.endsWith(".tsx") || f.endsWith(".ts")).map(f => join(srcPath, f));
        } catch {
            return [];
        }
    }

    // Centralized in helpers.ts

    private findOrCreatePropertyGroup(properties: any, groupName: string): any {
        if (!properties.propertyGroup) {
            properties.propertyGroup = [];
        } else if (!Array.isArray(properties.propertyGroup)) {
            properties.propertyGroup = [properties.propertyGroup];
        }

        let group = properties.propertyGroup.find((g: any) => g["@_caption"] === groupName);

        if (!group) {
            group = { "@_caption": groupName, property: [] };
            properties.propertyGroup.push(group);
        }

        return group;
    }

    private createPropertyXmlObject(property: PropertyDefinition): any {
        const obj: any = {
            "@_key": property.key,
            "@_type": property.type,
            caption: property.caption,
            description: property.description
        };

        if (property.required !== undefined) {
            obj["@_required"] = property.required.toString();
        }

        if (property.defaultValue !== undefined) {
            obj["@_defaultValue"] = property.defaultValue.toString();
        }

        if (property.type === "enumeration" && property.enumValues) {
            obj.enumerationValues = {
                enumerationValue: property.enumValues.map(value => ({ "@_key": value }))
            };
        }

        if (property.type === "attribute" && property.attributeTypes) {
            obj.attributeTypes = {
                attributeType: property.attributeTypes.map(type => ({ "@_name": type }))
            };
        }

        return obj;
    }

    // No TypeScript type mapping here. Typings are generated by pluggable-widgets-tools.

    /**
     * Run pluggable-widgets-tools to regenerate typings after XML/property changes are applied.
     * Prefers build:ts > release:ts > build scripts. Returns command output for logging.
     */
    async regenerateTypings(
        packagePath: string
    ): Promise<{ success: boolean; command?: string; stdout?: string; stderr?: string; error?: string }> {
        const exec = promisify(execCallback);

        try {
            const packageJsonPath = join(packagePath, "package.json");
            const packageJsonRaw = await readFile(packageJsonPath, "utf-8");
            const packageJson = JSON.parse(packageJsonRaw);
            const scripts: Record<string, string> = packageJson.scripts || {};

            let command = "pnpm build";
            if (scripts["build:ts"]) {
                command = "pnpm build:ts";
            } else if (scripts["release:ts"]) {
                command = "pnpm release:ts";
            } else if (scripts.build) {
                command = scripts.build.startsWith("pnpm ") ? scripts.build : "pnpm build";
            }

            const { stdout, stderr } = await exec(command, { cwd: packagePath });
            return { success: true, command, stdout: stdout?.slice(-1000), stderr: stderr?.slice(-500) };
        } catch (error) {
            return { success: false, error: error instanceof Error ? error.message : String(error) };
        }
    }
}
